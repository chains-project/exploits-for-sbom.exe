Here we discuss the JDK versions required to exploit `log4shell` vulnerability.
For all the versions, the [org.apache.logging.log4j:log4j-core:2.14.1](https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.14.1) is used.

## Pre-requisites

1. Build the project by running `mvn clean package -DskipTest`. Use JDK 11 
   atleast to build the project. You should have 
   `rq2/log4shell-2021-44228/target/log4shell-2021-44228-1.0-SNAPSHOT.jar` 
   file as the build output.

2. Build rogue-jndi server by executing `mvn clean package 
   -DskipTests` in the `rogue-jndi` directory.
   Next run the server by executing `java -jar target/RogueJndi-1.1.jar 
   --command shotwell hacker.jpeg`.

## JDK 11

Switch to any vendor or minor/patch version of JDK 11 and then run `./malicious.sh` script.

Expect Shotwell Image Viewer to open with the image `hacker.jpeg`.

## JDK 17

Now notice `-Dcom.sun.jndi.ldap.object.trustURLCodebase=true` argument in the `malicious.sh` script.
This argument is _required_ to exploit the vulnerability in JDK 17.
> It was not needed in JDK 11. But it was there as we run our experiments on 
> JDK 17 by default.

To understand why the attack could be successful in JDK 17, we particularly 
look at JDK17.0.10-Temurin.

Look at [com.sun.naming.internal.VersionHelper](https://github.com/adoptium/jdk/blob/e7e20d4ec62a3636a1a37f4ecdf4c30a11b0650f/src/java.naming/share/classes/com/sun/naming/internal/VersionHelper.java#L103-L113).
`-Dcom.sun.jndi.ldap.object.trustURLCodebase=true` is required to set 
`TRUST_URL_CODE_BASE` to `true` in JDK 17.
Eventually, the malicious code in initialized when a [new instance of the 
class](https://github.com/adoptium/jdk/blob/jdk-17%2B10/src/java.naming/share/classes/javax/naming/spi/NamingManager.java#L168) is created.

## JDK 21

The attack is not successful even if the `-Dcom.sun.jndi.ldap.object.trustURLCodebase=true` argument is passed in the `malicious.sh` script.

Let's look at code segments that help mitigate the attack in JDK 21-OpenJDK.

Because of `-Dcom.sun.jndi.ldap.object.trustURLCodebase=true`, we can bypass 
[com.sun.naming.internal.VersionHelper](https://github.com/openjdk/jdk/blob/8ff2928a04aeec8c09ff4a1ec4e83d4c9010950e/src/java.naming/share/classes/com/sun/naming/internal/VersionHelper.java#L108-L118).
However, the attack is mitigated by filters applied by [ObjectInputFilter](https://github.com/openjdk/jdk/blob/jdk-21%2B2/src/java.base/share/classes/java/io/ObjectInputFilter.java).
Specifically, there is a filter which checks if the module name matches 
`java.naming` [here](https://github.com/openjdk/jdk/blob/8ff2928a04aeec8c09ff4a1ec4e83d4c9010950e/src/java.base/share/classes/java/io/ObjectInputFilter.java#L1108).
I have not investigated if this filter can be manipulated to bypass.
